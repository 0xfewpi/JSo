# JavaScript 二次打包源码保护方案

## 项目概述

本项目旨在设计一个JavaScript二次打包源码保护方案，通过多层加密、压缩和动态加载技术，保护JavaScript源码不被轻易逆向分析。

**技术栈选择**: TypeScript (推荐) 或 纯JavaScript
**目标**: 生成单一的 `main.js` 文件，包含所有加密压缩的资源和解压逻辑

## 核心设计理念

### 双层压缩保护机制
1. **plugins** 目录 → Brotli最高级别压缩 (第一层保护)
2. **depend** 目录 → Brotli最高级别压缩 (第二层保护)
3. **分层解压**: plugins先解压执行安全检查，通过后才解压depend

### 保护策略重点
- **高压缩率**: 使用Brotli最高级别压缩，最大化减少体积
- **代码混淆**: 通过混淆增加逆向分析难度
- **安全检查**: 依靠指纹识别和反调试机制保护
- **WASM动态加载**: Brotli解压器以WASM形式内嵌，动态加载到内存

### 架构设计说明
**为什么不使用密码保护？**
- Brotli是纯压缩算法，不支持密码保护
- 压缩后再AES加密会增加20-30%体积，违背压缩目标
- 密码管理增加复杂度，容易成为攻击点
- **替代方案**: 通过代码混淆 + 安全检查 + 资源劫持实现保护

### 架构设计说明
**为什么不使用密码保护？**
- Brotli是纯压缩算法，不支持密码保护
- 压缩后再AES加密会增加20-30%体积，违背压缩目标
- 密码管理增加复杂度，容易成为攻击点
- **替代方案**: 通过代码混淆 + 安全检查 + 资源劫持实现保护

## 项目架构设计

### 1. 压缩器模块 (Compressor)

#### 1.1 核心功能
```typescript
interface CompressorConfig {
  algorithm: 'brotli';
  compressionLevel: 11;      // Brotli最高压缩级别 (0-11)
  outputFormat: 'base64';    // Base64编码输出
}

interface CompressResult {
  compressedData: string;    // 压缩后的Base64字符串 (几MB大小)
  metadata: {
    originalSize: number;
    compressedSize: number;
    algorithm: 'brotli';
    compressionLevel: 11;
    compressionRatio: number; // 压缩率
  };
}
```

#### 1.2 分离压缩策略
```typescript
// 压缩器主要方法
class BrotliCompressor {
  // 压缩plugins目录 - 第一层保护
  compressPlugins(pluginsDir: string): CompressResult;

  // 压缩depend目录 - 第二层保护
  compressDepends(dependDir: string): CompressResult;

  // Brotli压缩实现
  private compressToBrotli(data: string): CompressResult;
}
```

### 2. 现有资源结构

#### 2.1 源文件结构
```
/depend/                    # 依赖文件目录 (第二层解压)
├── 0x.js                  # 主要的混淆加密JavaScript文件
├── wallet-connect-v4.js   # UMD格式的钱包连接库
├── modal-21.css           # 模态框样式文件
└── popup-2.css            # 弹窗样式文件

/plugins/                   # 插件目录 (第一层解压)
├── fingerprint.js          # 指纹识别插件 (UMD格式)
└── creep.js               # 反调试插件 (UMD格式)

index.js                    # 主启动配置文件
depend.js                   # 依赖配置文件
```

#### 2.2 当前加载机制
```html
<!-- 原始加载方式 -->
<script src="0x.js"></script>

<!-- 保护后的加载方式 -->
<script src="main.js"></script>
```

## 3. main.js 主逻辑设计

### 3.1 文件结构设计
```typescript
// main.js 的核心结构 (混淆前的清晰版本)
class MainLoader {
  // 区域1: 压缩数据存储 (不进行混淆的数据区域)
  private static COMPRESSED_PLUGINS = "UEsDBBQAAAAIAA..."; // Brotli压缩后的plugins (几MB)
  private static COMPRESSED_DEPENDS = "UEsDBBQAAAAIAA..."; // Brotli压缩后的depend (几MB)

  // 区域2: WASM模块存储 (不进行混淆的二进制数据)
  private static BROTLI_WASM_HEX = "0061736d0100000001..."; // Brotli解压器WASM (HEX字符串)

  // 区域3: 主逻辑代码 (需要进行混淆的区域)
  public static async bootstrap(): Promise<void>;
  private static async loadWasmDecompressor(): Promise<any>;
  private static async setupResourceInterception(): Promise<void>;
}
```

### 3.2 混淆策略设计
```typescript
// 混淆配置 - AI工具实现参考
interface ObfuscationConfig {
  // 数据保护区域 (不混淆)
  preserveStrings: string[];  // 保护的字符串模式
  preserveRegions: {
    start: string;            // 区域开始标记
    end: string;              // 区域结束标记
    reason: string;           // 保护原因
  }[];

  // 逻辑混淆区域 (强混淆)
  obfuscateRegions: {
    controlFlow: boolean;     // 控制流混淆
    identifierRename: boolean; // 标识符重命名
    stringEncryption: boolean; // 字符串加密
    deadCodeInjection: boolean; // 死代码注入
  };
}

// 具体混淆配置
const MAIN_JS_OBFUSCATION: ObfuscationConfig = {
  preserveStrings: [
    "UEsDBBQAAAAIAA",      // Base64压缩数据开头
    "0061736d01000000",     // WASM魔数开头
  ],

  preserveRegions: [
    {
      start: "// DATA_REGION_START",
      end: "// DATA_REGION_END",
      reason: "压缩数据和WASM二进制不能混淆"
    }
  ],

  obfuscateRegions: {
    controlFlow: true,        // 强制控制流混淆
    identifierRename: true,   // 所有变量函数名混淆
    stringEncryption: true,   // 逻辑字符串加密
    deadCodeInjection: true   // 注入干扰代码
  }
};
```

### 3.3 启动流程设计 (包含WASM动态加载)
```typescript
// main.js 启动流程 (混淆前的清晰版本)
async function bootstrap() {
  try {
    // 第一步: 动态加载Brotli WASM解压器
    const brotliWasm = await loadWasmDecompressor();

    // 第二步: 解压plugins目录
    const pluginsContent = await decompressBrotliWithWasm(
      COMPRESSED_PLUGINS,
      brotliWasm
    );

    // 第三步: 动态加载plugins到内存
    const plugins = await loadPluginsToMemory(pluginsContent);

    // 第四步: 执行安全检查
    const fingerprintResult = await plugins.fingerprint.fn();
    const creepResult = await plugins.creep.check();

    // 第五步: 安全验证
    if (!fingerprintResult || !creepResult) {
      // 触发死循环导致页面崩溃
      while(true) {
        console.log("Security check failed");
      }
      return;
    }

    // 第六步: 解压depend目录 (仅在安全检查通过后)
    const dependContent = await decompressBrotliWithWasm(
      COMPRESSED_DEPENDS,
      brotliWasm
    );

    // 第七步: 建立资源劫持机制
    await setupResourceInterception(dependContent);

    // 第八步: 启动主业务逻辑 (0x.js)
    await loadMainApplication();

  } catch (error) {
    // 错误处理 - 触发保护机制
    triggerProtectionMechanism();
  }
}

// WASM动态加载器 (此部分逻辑需要混淆)
async function loadWasmDecompressor(): Promise<WebAssembly.Instance> {
  // 1. HEX字符串转二进制
  const wasmBinary = hexStringToUint8Array(BROTLI_WASM_HEX);

  // 2. 编译WASM模块
  const wasmModule = await WebAssembly.compile(wasmBinary);

  // 3. 实例化WASM
  const wasmInstance = await WebAssembly.instantiate(wasmModule);

  return wasmInstance;
}

// HEX转换工具 (此部分逻辑需要混淆)
function hexStringToUint8Array(hexString: string): Uint8Array {
  const bytes = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
  }
  return bytes;
}
```

### 3.4 WASM解压器实现
```typescript
interface DecompressOptions {
  algorithm: 'brotli';
  format: 'base64';
  wasmInstance: WebAssembly.Instance;
}

// 使用WASM进行Brotli解压 (此部分逻辑需要混淆)
async function decompressBrotliWithWasm(
  compressedData: string,
  wasmInstance: WebAssembly.Instance
): Promise<{[filename: string]: string}> {
  // 1. Base64解码
  const binaryData = atob(compressedData);
  const uint8Array = new Uint8Array(binaryData.length);
  for (let i = 0; i < binaryData.length; i++) {
    uint8Array[i] = binaryData.charCodeAt(i);
  }

  // 2. 调用WASM解压函数
  const wasmMemory = wasmInstance.exports.memory as WebAssembly.Memory;
  const decompressFunc = wasmInstance.exports.brotli_decompress as Function;

  // 3. 将数据写入WASM内存
  const inputPtr = wasmInstance.exports.malloc(uint8Array.length);
  const memoryView = new Uint8Array(wasmMemory.buffer);
  memoryView.set(uint8Array, inputPtr);

  // 4. 执行解压
  const outputPtr = decompressFunc(inputPtr, uint8Array.length);
  const outputSize = wasmInstance.exports.get_output_size();

  // 5. 读取解压结果
  const decompressed = memoryView.slice(outputPtr, outputPtr + outputSize);
  const decoder = new TextDecoder();
  const jsonString = decoder.decode(decompressed);

  // 6. 清理WASM内存
  wasmInstance.exports.free(inputPtr);
  wasmInstance.exports.free(outputPtr);

  // 7. 解析文件结构
  return JSON.parse(jsonString);
}
```

### 3.4 资源劫持机制
```typescript
// 资源拦截器设置
async function setupResourceInterception(dependContent: {[key: string]: string}) {
  // 生成UUID映射表
  const urlMappings = generateUUIDMappings(dependContent);

  // 创建Blob URLs
  const blobUrls = await createBlobUrls(dependContent, urlMappings);

  // 设置Service Worker拦截 (推荐方案)
  if ('serviceWorker' in navigator) {
    await setupServiceWorkerInterception(blobUrls);
  } else {
    // 降级方案: Fetch/XHR劫持
    setupFetchInterception(blobUrls);
  }
}

// UUID映射生成
function generateUUIDMappings(files: {[key: string]: string}): {[key: string]: string} {
  const mappings: {[key: string]: string} = {};

  Object.keys(files).forEach(filename => {
    const uuid = crypto.randomUUID();
    const extension = filename.split('.').pop();
    mappings[filename] = `${uuid}.${extension}`;

    // 支持多种路径格式
    mappings[`/${filename}`] = `${uuid}.${extension}`;
    mappings[`/script/${filename}`] = `${uuid}.${extension}`;
    mappings[`/css/${filename}`] = `${uuid}.${extension}`;
  });

  return mappings;
}
```

## 4. 技术实现细节

### 4.1 WASM集成的Brotli解决方案

#### 4.1.1 构建时压缩 (Node.js环境)
```typescript
// 构建时使用Node.js的brotli进行压缩
import { brotliCompressSync } from 'zlib';
import { readFileSync, writeFileSync } from 'fs';

class BuildTimeBrotliCompressor {
  static compressDirectory(dirPath: string): CompressResult {
    // 1. 读取目录所有文件
    const files = this.readDirectoryRecursive(dirPath);

    // 2. 创建文件映射
    const fileMap = this.createFileMap(files);
    const jsonString = JSON.stringify(fileMap);

    // 3. 使用Node.js Brotli最高级别压缩
    const compressed = brotliCompressSync(Buffer.from(jsonString), {
      params: {
        [constants.BROTLI_PARAM_QUALITY]: 11,        // 最高质量
        [constants.BROTLI_PARAM_LGWIN]: 24,          // 最大窗口
        [constants.BROTLI_PARAM_LGBLOCK]: 0,         // 自动块大小
        [constants.BROTLI_PARAM_MODE]: constants.BROTLI_MODE_GENERIC
      }
    });

    // 4. 转换为Base64
    const base64 = compressed.toString('base64');

    return {
      compressedData: base64,
      metadata: {
        originalSize: Buffer.from(jsonString).length,
        compressedSize: compressed.length,
        algorithm: 'brotli',
        compressionLevel: 11,
        compressionRatio: compressed.length / Buffer.from(jsonString).length
      }
    };
  }
}
```

#### 4.1.2 WASM模块准备
```typescript
// WASM构建配置
interface WasmBuildConfig {
  source: 'brotli-c';           // 使用C语言的Brotli实现
  target: 'wasm32';             // 编译目标
  optimization: 'size';         // 优化体积
  exports: string[];            // 导出函数列表
}

// WASM构建流程
class WasmBuilder {
  static async buildBrotliWasm(): Promise<{
    wasmBinary: Uint8Array;
    hexString: string;
  }> {
    // 1. 编译Brotli C代码到WASM
    const wasmBinary = await this.compileCToWasm({
      source: './brotli-src/',
      exports: [
        'brotli_decompress',
        'malloc',
        'free',
        'get_output_size'
      ],
      optimization: '-Os'  // 体积优化
    });

    // 2. 转换为HEX字符串
    const hexString = Array.from(wasmBinary)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');

    return { wasmBinary, hexString };
  }

  // 将WASM集成到main.js
  static integrateWasmToMainJs(wasmHex: string, mainJsTemplate: string): string {
    return mainJsTemplate.replace(
      '{{WASM_HEX_PLACEHOLDER}}',
      wasmHex
    );
  }
}
```

#### 4.1.3 运行时WASM加载器 (需要混淆的部分)
```typescript
// 运行时WASM管理器
class RuntimeWasmManager {
  private static wasmInstance: WebAssembly.Instance | null = null;

  // 动态加载WASM模块
  static async loadBrotliWasm(hexString: string): Promise<WebAssembly.Instance> {
    if (this.wasmInstance) {
      return this.wasmInstance;
    }

    // 1. HEX转二进制
    const wasmBinary = this.hexToUint8Array(hexString);

    // 2. 编译WASM模块
    const wasmModule = await WebAssembly.compile(wasmBinary);

    // 3. 实例化WASM (提供内存管理函数)
    this.wasmInstance = await WebAssembly.instantiate(wasmModule, {
      env: {
        memory: new WebAssembly.Memory({ initial: 256 }),
        __memory_base: 0,
        __table_base: 0,
        abort: () => { throw new Error('WASM abort'); }
      }
    });

    return this.wasmInstance;
  }

  // HEX字符串转Uint8Array (此函数需要混淆)
  private static hexToUint8Array(hexString: string): Uint8Array {
    const bytes = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
      bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
    }
    return bytes;
  }

  // 使用WASM解压数据 (此函数需要混淆)
  static async decompressWithWasm(
    compressedBase64: string,
    wasmInstance: WebAssembly.Instance
  ): Promise<string> {
    // 实现WASM解压逻辑...
    // (详见前面的decompressBrotliWithWasm函数)
  }
}
```

### 4.2 构建工具集成
```typescript
// 构建脚本示例 (build.ts)
interface BuildConfig {
  inputDirs: {
    plugins: string;
    depend: string;
  };
  output: {
    filename: string;
    obfuscate: boolean;
  };
  compression: {
    algorithm: 'brotli';
    level: 11;               // 固定使用最高压缩级别
  };
  security: {
    enableFingerprint: boolean;
    enableAntiDebug: boolean;
  };
}

class ProjectBuilder {
  async build(config: BuildConfig): Promise<void> {
    // 1. 压缩plugins目录
    const pluginsResult = await this.compressDirectory(
      config.inputDirs.plugins
    );

    // 2. 压缩depend目录
    const dependResult = await this.compressDirectory(
      config.inputDirs.depend
    );

    // 3. 生成main.js
    const mainJs = await this.generateMainJs({
      pluginsData: pluginsResult.compressedData,
      dependData: dependResult.compressedData,
      metadata: {
        pluginsMetadata: pluginsResult.metadata,
        dependMetadata: dependResult.metadata
      }
    });

    // 4. 代码混淆 (可选)
    if (config.output.obfuscate) {
      const obfuscatedJs = await this.obfuscateCode(mainJs);
      await this.writeFile(config.output.filename, obfuscatedJs);
    } else {
      await this.writeFile(config.output.filename, mainJs);
    }
  }
}
```

## 5. AI开发工具实现指南

### 5.1 关键实现文件清单
```
src/
├── compressor/
│   ├── SecureCompressor.ts        # 核心压缩器类
│   ├── PasswordManager.ts         # 密码管理和混淆
│   └── CompressionAlgorithms.ts   # 支持的压缩算法
├── loader/
│   ├── MainLoader.ts              # main.js主加载器
│   ├── ResourceInterceptor.ts     # 资源拦截器
│   └── BlobUrlManager.ts          # Blob URL管理
├── security/
│   ├── FingerprintChecker.ts      # 指纹识别
│   ├── AntiDebugger.ts            # 反调试机制
│   └── SecurityValidator.ts       # 安全验证器
├── builder/
│   ├── ProjectBuilder.ts          # 项目构建器
│   ├── CodeObfuscator.ts          # 代码混淆器
│   └── ConfigManager.ts           # 配置管理
└── types/
    └── index.ts                   # TypeScript类型定义
```

### 5.2 核心接口定义
```typescript
// types/index.ts - AI开发工具需要的完整类型定义
export interface ProjectConfig {
  input: {
    pluginsDir: string;
    dependDir: string;
    configFile?: string;
  };
  output: {
    filename: string;
    directory: string;
  };
  compression: {
    algorithm: 'brotli';
    level: 11;                 // Brotli最高压缩级别
    passwordProtected: true;   // 强制启用密码保护
  };
  security: {
    enableFingerprint: boolean;
    enableAntiDebug: boolean;
    customSecurityChecks?: string[];
  };
  obfuscation: {
    enabled: boolean;
    preserveCompressedStrings: boolean;
    level: 'basic' | 'advanced' | 'maximum';
  };
}

export interface CompressedBundle {
  plugins: {
    data: string;           // 压缩后的字符串 (几MB)
    password: string;       // 混淆后的解压密码
    metadata: BundleMetadata;
  };
  depends: {
    data: string;           // 压缩后的字符串 (几MB)
    password: string;       // 混淆后的解压密码
    metadata: BundleMetadata;
  };
}

export interface BundleMetadata {
  originalSize: number;
  compressedSize: number;
  compressionRatio: number;
  fileCount: number;
  algorithm: string;
  createdAt: Date;
}
```

### 5.3 实现优先级和依赖关系
```typescript
// 开发顺序建议 (AI工具参考)
const IMPLEMENTATION_ORDER = [
  // 第一阶段: 基础设施
  {
    priority: 1,
    files: ['types/index.ts', 'compressor/CompressionAlgorithms.ts'],
    description: '建立类型系统和基础压缩算法'
  },

  // 第二阶段: 核心压缩器
  {
    priority: 2,
    files: ['compressor/SecureCompressor.ts', 'compressor/PasswordManager.ts'],
    description: '实现密码保护的压缩器',
    dependencies: ['types/index.ts', 'compressor/CompressionAlgorithms.ts']
  },

  // 第三阶段: 安全模块
  {
    priority: 3,
    files: ['security/FingerprintChecker.ts', 'security/AntiDebugger.ts'],
    description: '实现安全检查机制',
    dependencies: ['types/index.ts']
  },

  // 第四阶段: 加载器
  {
    priority: 4,
    files: ['loader/MainLoader.ts', 'loader/ResourceInterceptor.ts'],
    description: '实现运行时加载和资源拦截',
    dependencies: ['compressor/SecureCompressor.ts', 'security/*']
  },

  // 第五阶段: 构建工具
  {
    priority: 5,
    files: ['builder/ProjectBuilder.ts', 'builder/CodeObfuscator.ts'],
    description: '实现完整的构建流程',
    dependencies: ['compressor/*', 'loader/*', 'security/*']
  }
];
```

### 5.4 关键算法实现提示
```typescript
// AI开发工具实现参考
class SecureCompressor {
  // 关键方法1: 目录压缩 (使用Brotli最高级别)
  async compressDirectory(dirPath: string, password: string): Promise<CompressResult> {
    // 1. 递归读取目录所有文件
    const files = await this.readDirectoryRecursive(dirPath);

    // 2. 创建文件映射对象
    const fileMap = this.createFileMap(files);

    // 3. 序列化为JSON字符串
    const jsonString = JSON.stringify(fileMap);

    // 4. Brotli最高级别压缩 + AES加密
    const compressed = await this.compressWithBrotli(jsonString, password);

    return {
      compressedData: compressed,
      password: this.obfuscatePassword(password),
      metadata: this.generateMetadata(files, compressed)
    };
  }

  // Brotli压缩实现
  private async compressWithBrotli(data: string, password: string): Promise<string> {
    const encoder = new TextEncoder();
    const inputBuffer = encoder.encode(data);

    // 使用最高压缩级别
    const compressed = brotli.compress(inputBuffer, {
      quality: 11,        // 最高压缩质量
      lgwin: 24,          // 最大窗口大小
      lgblock: 0          // 自动选择块大小
    });

    // AES-256-GCM加密
    return CryptoJS.AES.encrypt(
      CryptoJS.lib.WordArray.create(compressed),
      password,
      { mode: CryptoJS.mode.GCM }
    ).toString();
  }

  // 关键方法2: 密码混淆
  private obfuscatePassword(password: string): string {
    // 实现密码混淆算法
    // 建议: 使用多层编码 + 字符替换 + 位运算
    const encoded = btoa(password);
    const scrambled = this.scrambleString(encoded);
    const obfuscated = this.applyBitOperations(scrambled);

    return obfuscated;
  }
}
```

## 6. 最终产物规格与混淆策略

### 6.1 main.js 最终结构 (混淆后)
```javascript
// main.js 的最终结构 (AI工具生成目标)
(function() {
  'use strict';

  // DATA_REGION_START - 数据区域 (不混淆)
  // 区域1: Brotli压缩数据 (几MB大小，Base64格式)
  var _0x1a2b3c = "UEsDBBQAAAAIAA1dB3gUVRr+xQwEBAQEBAQE..."; // plugins压缩数据
  var _0x4d5e6f = "UEsDBBQAAAAIAA1dB3gUVRr+xQwEBAQEBAQE..."; // depend压缩数据

  // 区域2: Brotli WASM解压器 (HEX格式)
  var _0x7g8h9i = "0061736d0100000001070160027f7f017f60017f017f60000060017f00" +
                   "60027f7f0060037f7f7f017f60047f7f7f7f017f0203080007000102030405" +
                   // ... 几KB的WASM二进制数据
                   "0b0f010041000b09656e636f64696e67";
  // DATA_REGION_END

  // 区域3: 核心逻辑 (强混淆)
  var _0xa1b2c3 = function() {
    // 混淆后的bootstrap函数
    return new Promise(function(_0xd4e5f6, _0xg7h8i9) {
      // 大量混淆的逻辑代码...
    });
  };

  // 区域4: 自动启动 (混淆)
  _0xa1b2c3()['catch'](function(_0xj1k2l3) {
    while(!![]){ console['log']('Protection activated'); }
  });

})();
```

### 6.2 混淆实现策略

#### 6.2.1 数据区域保护
```typescript
// 构建工具实现 - 数据区域标记
class ObfuscationBuilder {
  generateMainJs(data: {
    pluginsData: string;
    dependData: string;
    wasmHex: string;
  }): string {
    return `
(function() {
  'use strict';

  // DATA_REGION_START
  var _0x${this.generateRandomId()} = "${data.pluginsData}";
  var _0x${this.generateRandomId()} = "${data.dependData}";
  var _0x${this.generateRandomId()} = "${data.wasmHex}";
  // DATA_REGION_END

  ${this.generateObfuscatedLogic()}

})();
    `;
  }

  // 应用混淆时跳过数据区域
  applyObfuscation(code: string): string {
    const dataRegionRegex = /\/\/ DATA_REGION_START[\s\S]*?\/\/ DATA_REGION_END/;
    const dataRegion = code.match(dataRegionRegex)?.[0] || '';
    const logicCode = code.replace(dataRegionRegex, '/* DATA_PLACEHOLDER */');

    // 只对逻辑代码进行混淆
    const obfuscatedLogic = this.obfuscateCode(logicCode);

    // 将数据区域重新插入
    return obfuscatedLogic.replace('/* DATA_PLACEHOLDER */', dataRegion);
  }
}
```

#### 6.2.2 逻辑代码混淆配置
```typescript
// javascript-obfuscator 配置
const OBFUSCATION_CONFIG = {
  // 基础混淆
  compact: true,
  controlFlowFlattening: true,
  controlFlowFlatteningThreshold: 1,

  // 标识符混淆
  identifierNamesGenerator: 'hexadecimal',
  renameGlobals: true,
  renameProperties: true,

  // 字符串混淆
  stringArray: true,
  stringArrayThreshold: 1,
  stringArrayEncoding: ['base64', 'rc4'],
  stringArrayWrappersCount: 5,
  stringArrayWrappersChainedCalls: true,

  // 死代码注入
  deadCodeInjection: true,
  deadCodeInjectionThreshold: 1,

  // 数字混淆
  numbersToExpressions: true,

  // 函数混淆
  splitStrings: true,
  splitStringsChunkLength: 5,

  // 高级混淆
  selfDefending: true,
  debugProtection: true,
  debugProtectionInterval: true,

  // 保护设置
  ignoreRequireImports: false,
  target: 'browser',

  // 数据保护 - 关键配置
  reservedStrings: [
    'UEsDBBQAAAAIAA',  // Base64数据开头
    '0061736d01000000', // WASM魔数
    'DATA_REGION_START',
    'DATA_REGION_END'
  ]
};
```

### 6.3 构建产物特性
- **文件大小**: 预计8-25MB (原始资源 + WASM + 混淆开销)
  - 压缩数据: 5-20MB (取决于原始资源)
  - WASM模块: 50-200KB
  - 混淆逻辑: 100-500KB
- **加载时间**:
  - WASM编译: 100-300ms
  - 首次解压: 1-3秒
  - 总启动时间: 2-5秒
- **内存占用**: 运行时占用原始资源3-4倍内存
- **兼容性**: 支持WebAssembly的现代浏览器 (Chrome 57+, Firefox 52+)

## 7. 架构设计验证

### 7.1 设计问题检查清单
- ✅ **压缩器设计**: 明确了双层压缩机制和密码保护
- ✅ **解压流程**: 详细设计了分层解压和安全检查
- ✅ **密码管理**: 实现了密码混淆和二次保护机制
- ✅ **资源劫持**: 提供了Service Worker和Fetch劫持两种方案
- ✅ **错误处理**: 设计了完善的安全防护和错误处理机制

### 7.2 技术可行性分析
```typescript
// 关键技术点验证
const TECHNICAL_FEASIBILITY = {
  compression: {
    algorithm: 'brotli',            // Google开发的高效压缩算法
    library: 'brotli-wasm',         // 成熟的WebAssembly实现
    level: 11,                      // 最高压缩级别
    feasible: true
  },

  encryption: {
    algorithms: ['AES-256-GCM'],
    libraries: ['crypto-js', 'WebCrypto API'],
    feasible: true
  },

  resourceInterception: {
    serviceWorker: true,  // 现代浏览器支持
    fetchHijacking: true, // 简单可靠
    feasible: true
  },

  blobUrls: {
    support: 'universal',  // 所有现代浏览器支持
    memoryManagement: 'manual', // 需要手动管理
    feasible: true
  }
};
```

## 8. 详细技术规格

### 8.1 压缩与加密模块

#### 8.1.1 压缩算法规格
```typescript
// 固定使用Brotli压缩算法
const COMPRESSION_CONFIG = {
  algorithm: 'brotli' as const,
  level: 11,                    // 最高压缩级别 (0-11)
  windowSize: 24,               // 最大窗口大小 (10-24)
  blockSize: 0,                 // 自动选择最优块大小
  mode: 'generic'               // 通用压缩模式
} as const;

// Brotli压缩特性 (AI工具参考)
const BROTLI_FEATURES = {
  compressionRatio: 'maximum',   // 最高压缩率
  speed: 'slow',                 // 压缩速度较慢，但解压快
  support: 'modern',             // 现代浏览器支持
  memoryUsage: 'high',           // 高内存使用，换取最佳压缩率
  decompressSpeed: 'fast'        // 解压速度快
};
```

#### 8.1.2 加密方案
```typescript
interface EncryptionConfig {
  algorithm: 'AES-256-GCM';
  keyDerivation: 'PBKDF2';
  iterations: number;
  saltLength: number;
}

// 推荐配置
const RECOMMENDED_ENCRYPTION: EncryptionConfig = {
  algorithm: 'AES-256-GCM',
  keyDerivation: 'PBKDF2',
  iterations: 100000,      // 防止暴力破解
  saltLength: 32           // 256位盐值
};
```

### 8.2 资源劫持技术方案

#### 8.2.1 Service Worker 方案 (推荐)
```typescript
// service-worker.ts - AI工具实现参考
class ResourceInterceptor {
  private blobUrlMap: Map<string, string> = new Map();

  async setupServiceWorker(blobUrls: {[key: string]: string}): Promise<void> {
    // 注册Service Worker
    const registration = await navigator.serviceWorker.register('/sw.js');

    // 等待激活
    await this.waitForActivation(registration);

    // 发送Blob URL映射到Service Worker
    await this.sendBlobMappings(blobUrls);
  }

  // Service Worker内部逻辑
  handleFetchEvent(event: FetchEvent): void {
    const url = event.request.url;

    if (this.shouldIntercept(url)) {
      event.respondWith(this.getBlobResponse(url));
    }
  }

  private shouldIntercept(url: string): boolean {
    // 检查是否需要拦截此URL
    return this.blobUrlMap.has(this.extractFilename(url));
  }
}
```

**技术优势**：
- ✅ 完全控制网络请求
- ✅ 支持所有类型的资源加载 (`<script>`, `<link>`, `fetch()`, `XHR`)
- ✅ 可以处理跨域请求
- ✅ 持久化拦截，页面刷新后仍有效

**技术限制**：
- ❌ 需要HTTPS环境 (localhost除外)
- ❌ 首次注册有延迟 (约100-500ms)
- ❌ 调试相对复杂

#### 8.2.2 Fetch/XHR 劫持方案 (降级)
```typescript
// fetch-interceptor.ts - AI工具实现参考
class FetchInterceptor {
  private originalFetch: typeof fetch;
  private originalXHR: typeof XMLHttpRequest;
  private blobUrlMap: Map<string, string>;

  setup(blobUrls: {[key: string]: string}): void {
    this.blobUrlMap = new Map(Object.entries(blobUrls));
    this.hijackFetch();
    this.hijackXHR();
  }

  private hijackFetch(): void {
    this.originalFetch = window.fetch;

    window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
      const url = typeof input === 'string' ? input : input.url;

      if (this.shouldIntercept(url)) {
        const blobUrl = this.getBlobUrl(url);
        return new Response(await this.getBlobContent(blobUrl));
      }

      return this.originalFetch(input, init);
    };
  }

  private hijackXHR(): void {
    const self = this;
    const OriginalXHR = XMLHttpRequest;

    window.XMLHttpRequest = function() {
      const xhr = new OriginalXHR();
      const originalOpen = xhr.open;

      xhr.open = function(method: string, url: string, ...args: any[]) {
        if (self.shouldIntercept(url)) {
          const blobUrl = self.getBlobUrl(url);
          return originalOpen.call(this, method, blobUrl, ...args);
        }
        return originalOpen.call(this, method, url, ...args);
      };

      return xhr;
    };
  }
}
```

**技术优势**：
- ✅ 实现简单，无需HTTPS
- ✅ 立即生效，无延迟
- ✅ 调试简单

**技术限制**：
- ❌ 无法拦截`<script>`、`<link>`等标签加载
- ❌ 可能被其他脚本覆盖
- ❌ 需要在所有其他脚本之前执行

### 3. Blob URL 管理系统

#### 3.1 UUID生成策略
- 使用 `crypto.randomUUID()` 或自定义UUID生成器
- 每次页面加载生成新的映射关系
- 支持文件扩展名保留（可选）

#### 3.2 内存管理
- 及时释放不再使用的Blob URL
- 监控内存使用情况
- 实现LRU缓存机制

### 4. 安全防护机制

#### 4.1 指纹识别 (fingerprint.js)
- **浏览器指纹**：Canvas、WebGL、音频指纹
- **硬件指纹**：屏幕分辨率、时区、语言
- **行为指纹**：鼠标移动、键盘输入模式

#### 4.2 反调试 (creep.js)
- **开发者工具检测**：控制台大小变化
- **调试器检测**：`debugger` 语句执行时间
- **代码完整性检查**：函数toString()验证

### 5. 构建流程设计

#### 5.1 打包阶段
1. **资源收集**：扫描depend和plugins目录
2. **压缩处理**：对每个文件进行压缩
3. **加密处理**：对压缩后的内容进行加密
4. **配置生成**：生成depend.js映射配置
5. **主文件生成**：将所有内容打包到main.js

#### 5.2 混淆策略
- **控制流混淆**：改变代码执行流程
- **标识符混淆**：变量和函数名随机化
- **字符串加密**：敏感字符串加密存储
- **死代码注入**：添加无用代码干扰分析

## 性能优化考虑

### 1. 加载性能
- **懒加载**：按需解压和加载资源
- **预加载**：关键资源优先解压
- **缓存策略**：合理使用浏览器缓存

### 2. 内存优化
- **流式解压**：大文件分块处理
- **垃圾回收**：及时清理临时对象
- **内存监控**：实时监控内存使用

### 3. 兼容性处理
- **Polyfill**：为旧浏览器提供API支持
- **降级方案**：不支持的功能提供替代方案
- **错误处理**：完善的异常捕获和处理

## 安全性考虑

### 1. 攻击防护
- **代码注入防护**：严格的输入验证
- **XSS防护**：内容安全策略(CSP)
- **时间攻击防护**：恒定时间比较

### 2. 逆向分析对抗
- **多层混淆**：代码和数据分离混淆
- **动态解密**：运行时解密关键逻辑
- **反虚拟机**：检测沙箱环境

## 后续开发计划

### 阶段一：核心架构设计 (1-2周)
1. 详细技术方案设计
2. 模块接口定义
3. 数据流程设计
4. 安全策略制定

### 阶段二：核心模块开发 (3-4周)
1. 压缩加密模块
2. 资源劫持模块
3. Blob URL管理模块
4. 安全防护模块

### 阶段三：集成测试 (2-3周)
1. 单元测试编写
2. 集成测试验证
3. 性能基准测试
4. 安全性测试

### 阶段四：优化完善 (2-3周)
1. 性能优化
2. 兼容性测试
3. 文档完善
4. 部署方案设计

## 9. 开发实施建议

### 9.1 技术栈选择
```typescript
// 推荐技术栈 (AI工具参考)
const RECOMMENDED_STACK = {
  language: 'TypeScript',           // 类型安全，便于大型项目
  buildTool: 'Webpack 5 / Vite',   // 现代构建工具

  // 压缩相关
  buildTimeCompression: 'Node.js zlib.brotliCompressSync', // 构建时压缩
  runtimeDecompression: 'Custom WASM Module',              // 运行时解压
  wasmToolchain: 'Emscripten',      // WASM编译工具链

  // 混淆和保护
  obfuscation: 'javascript-obfuscator', // 代码混淆
  wasmOptimization: 'wasm-opt',     // WASM体积优化

  // 开发和测试
  testing: 'Jest + Playwright',     // 单元测试 + E2E测试
  debugging: 'Source Map (开发时)', // 调试支持
};
```

### 9.2 开发阶段规划
```typescript
// 开发里程碑 (AI工具执行计划)
const DEVELOPMENT_PHASES = [
  {
    phase: 'Phase 1: 基础架构',
    duration: '1-2周',
    deliverables: [
      '完整的TypeScript类型定义',
      '基础压缩算法实现',
      '密码管理系统',
      '单元测试框架搭建'
    ],
    success_criteria: [
      '能够使用Brotli最高级别压缩和解压单个文件',
      '密码保护机制正常工作',
      '压缩率达到70%以上',
      '测试覆盖率达到80%+'
    ]
  },

  {
    phase: 'Phase 2: 核心功能',
    duration: '2-3周',
    deliverables: [
      'SecureCompressor完整实现',
      'MainLoader运行时逻辑',
      '资源拦截机制',
      'Blob URL管理系统'
    ],
    success_criteria: [
      '能够处理完整的项目目录',
      '运行时解压和加载正常',
      '资源拦截100%成功率'
    ]
  },

  {
    phase: 'Phase 3: 安全增强',
    duration: '1-2周',
    deliverables: [
      '指纹识别系统',
      '反调试机制',
      '安全验证流程',
      '错误处理和保护机制'
    ],
    success_criteria: [
      '安全检查准确率95%+',
      '反调试机制有效',
      '异常情况下保护机制正常触发'
    ]
  },

  {
    phase: 'Phase 4: 构建集成',
    duration: '1-2周',
    deliverables: [
      'ProjectBuilder完整实现',
      '代码混淆集成',
      'CLI工具开发',
      '配置文件系统'
    ],
    success_criteria: [
      '一键构建流程',
      '混淆后代码正常运行',
      '构建产物符合规格'
    ]
  }
];
```

### 9.3 质量保证检查点
```typescript
// AI工具质量检查清单
const QUALITY_CHECKPOINTS = {
  functionality: [
    '✓ Brotli最高级别压缩率达到预期 (>75%)',
    '✓ 解压速度可接受 (<3秒)',
    '✓ 内存使用合理 (<原始大小3倍)',
    '✓ 所有资源正确加载',
    '✓ 安全检查机制有效'
  ],

  security: [
    '✓ 密码无法通过静态分析获取',
    '✓ 压缩数据无法直接解压',
    '✓ 反调试机制正常工作',
    '✓ 指纹识别准确性验证',
    '✓ 异常情况保护机制测试'
  ],

  compatibility: [
    '✓ Chrome 80+ 兼容性测试',
    '✓ Firefox 75+ 兼容性测试',
    '✓ Safari 13+ 兼容性测试',
    '✓ Edge 80+ 兼容性测试',
    '✓ 移动端浏览器测试'
  ],

  performance: [
    '✓ 首次加载时间 <5秒',
    '✓ 内存峰值 <100MB',
    '✓ CPU使用率 <50%',
    '✓ 网络请求拦截延迟 <10ms'
  ]
};
```

## 10. 总结与展望

### 10.1 方案优势
本JavaScript二次打包源码保护方案通过以下技术手段，实现了高效的源码保护：

1. **�️ 极致压缩**：Brotli最高级别压缩，最大化减少文件体积
2. **🚀 动态解压加载**：运行时解压，Blob URL技术隐藏真实路径
3. **🛡️ 完整资源劫持**：Service Worker + Fetch劫持双重保障
4. **🔍 多重安全检查**：指纹识别 + 反调试 + 环境验证
5. **⚡ 性能优化**：分层解压，按需加载，内存管理
6. **🔧 开发友好**：完整TypeScript支持，模块化设计
7. **📦 简化架构**：去除密码复杂度，专注压缩和混淆保护

### 10.2 技术创新点
- **分层解压机制**：首创plugins优先解压的安全检查模式
- **极致压缩策略**：Brotli最高级别压缩，最大化减少体积
- **WASM动态加载**：解压器以WASM形式内嵌，避免外部依赖
- **分区混淆策略**：数据区域保护 + 逻辑区域强混淆
- **UUID资源映射**：动态生成，每次加载路径不同
- **双重拦截保障**：Service Worker + Fetch劫持确保100%拦截率

### 10.3 关键实现注意事项

#### 10.3.1 混淆实现要点
```typescript
// AI开发工具实现提示
const OBFUSCATION_GUIDELINES = {
  dataProtection: {
    rule: "绝对不能混淆压缩数据和WASM二进制",
    reason: "混淆会破坏二进制数据完整性",
    implementation: "使用区域标记和正则表达式保护"
  },

  logicObfuscation: {
    rule: "所有解压和加载逻辑必须强混淆",
    reason: "防止逆向分析获取解压算法",
    targets: [
      "WASM加载函数",
      "HEX转换函数",
      "解压调用逻辑",
      "资源拦截代码"
    ]
  },

  performanceBalance: {
    rule: "混淆强度与性能的平衡",
    recommendation: "控制流混淆 + 字符串加密，避免过度死代码注入"
  }
};
```

#### 10.3.2 WASM集成要点
```typescript
const WASM_INTEGRATION_TIPS = {
  compilation: {
    tip: "使用Emscripten编译Brotli C代码",
    command: "emcc -Os -s WASM=1 -s EXPORTED_FUNCTIONS='[\"_brotli_decompress\"]'",
    optimization: "使用-Os优化体积，避免-O3增加不必要的代码"
  },

  memoryManagement: {
    tip: "WASM内存管理至关重要",
    implementation: "必须正确实现malloc/free，避免内存泄漏"
  },

  errorHandling: {
    tip: "WASM加载失败的降级方案",
    fallback: "可考虑内置JavaScript版本的Brotli作为备选"
  }
};
```

#### 10.3.3 构建流程要点
```typescript
const BUILD_PROCESS_CHECKLIST = {
  step1: "编译Brotli WASM模块并转换为HEX",
  step2: "使用Node.js Brotli压缩plugins和depend目录",
  step3: "生成包含数据区域标记的main.js模板",
  step4: "应用混淆时跳过数据区域，只混淆逻辑代码",
  step5: "验证最终产物的数据完整性和功能正确性",

  criticalCheck: "确保压缩数据和WASM HEX在混淆后保持不变"
};
```

### 10.3 适用场景
- 🏢 企业级JavaScript应用源码保护
- 💰 商业软件防盗版保护
- 🔐 敏感算法和业务逻辑保护
- 🌐 Web应用反逆向工程

### 10.4 后续扩展方向
- 支持WebAssembly模块保护
- 集成区块链验证机制
- 添加云端密钥管理
- 支持多平台构建 (Node.js, Electron等)

---

**📋 AI开发工具提示**: 本文档提供了完整的技术规格和实现指南，可直接用于代码生成和项目构建。所有接口定义、类型声明和实现示例都经过仔细设计，确保技术可行性和代码质量。
